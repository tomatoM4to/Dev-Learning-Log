# 소유권
* Java는 더 이상 사용하지 않는 메모리를 정기적으로 찾는 방식을 채택
* C언어는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는방식
* ownership은 Rust가 프로그램의 메모리를 관리하는 규칙 모음이다.
    * 해당 규칙중 하나라도 위반할시, Rust 프로그램은 컴파일 되지 않고, 소유원의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.

***

# 스택 영역과 힙 영역
* 러스트 같은 시스템 프로그래밍 언어에서는 값을 스택에 저장하느냐 힙에 저장하느냐의 차이가 프로그램의 동작 및 프로그래머의 의사 결정에 훨씬 큰 영향을 미칩니다.
* 스택과 힙 둘다 프로그램의 런타임에 이용하게 될 메모리 영역이라는 공통점이 있지만, 구조가 다르다.
    * 스택: LIFO 방식이면서, 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다. 메모리 할당자가 새로운 데이터를 찾을 필요가 없이 항상 가장 위에 데이터를 저장하면 되기 때문에 힙보다 속도가 빠르다.
    * 힙: 데이터를 힙에 넣을때는 먼저 저장할 공간이 있는지 운영체제에 물어보고, 메모리 할당자는 커다란 힙 영역 안에서 어떤 빈 지점을 찾고, 이 지점을 사용 중 이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 반환한다. 이 과정을 allocating on heap, 줄여서 allocation 라고 한다(스택에 값을 push하는것은 allocation라고 하지는 않는다). 현대 프로세서는 메모리 내부를 이리저리 왔다 갔다 하는 작업이 적을수록 속도가 빨라지는데 힙에 있는 데이터들은 서로 멀리 떨어져 있어 프로세서가 계속해서 돌아다녀야 하기 떄문에 속도가 느리다. 반대로 스택 영역은 데이터가 서로 붙어 있으며 작업이 빠르다.
    * pointer: 크기가 정해져 있어, 스택에 저장할수 있으면서 포인터가 가리키는 실제 데이터를 사용하고자 할 때는 포인터를 참조해 해당 포인터가 가리키는 위치로 이동하는 과정을 거쳐야 한다.
    * 함수 호출: 호출한 함수에 넘겨준 값(pointer 포함)과 해당 함수의 지역변수 들이 스택에 push됀다. 그리고 이데 데이터들은 함수가 종료될 때 pop 된다.
* 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화 하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 소유권과 관련되어 있다, 즉 소유권의 주요 목표가 힙 데이터의 관리라는점

***

# 소유권 규칙
* 러스트에선, 각각의 값은 소유자(owner)가 정해져 있다.
* 한 값의 소유자는 동시에 여럿 존재할 수 없다.
* 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다.(dropped).

***

# 변수의 scope
* string literal은 String::new()와는 다르다. url: https://users.rust-lang.org/t/str-string-literals/29635
```rust
{                       // s는 아직 선언되지 않아서 여기서는 유효하지 않습니다
    let s = "hello";    // 이 지점부터 s가 유효합니다

                        // s로 어떤 작업을 합니다
}                       // 이 스코프가 종료되었고, s가 더 이상 유효하지 않습니다
```
* 중요한 포인트
    1. s가 스코프 내에 나타나면 유효하다.
    2. 유효기간은 스코프 밖으로 벗어나기 전까지다.

***

# 더 복잡한 타입
* 앞서 다룬것들은 명확한 크기를 가지고 있어, 전부 스택에 저장되고 스코프를 벗어날 때 제거된다.
* String type: 힙에 할당된 데이터를 다루기 때문에, 컴파일 타임에 크기를 알 수 없는 텍스트도 저장할 수 있다.
```rust
{
let mut s = String::from("hello");
s.push_str(", world!"); // push_str()이 문자열에 리터럴을 추가합니다
println!("{}", s); // 이 줄이 `hello, world!`를 출력합니다
} // 스코프가 종료되었고, s는 더이상 유효하지 않는다, drop 이라는 특별한 함수를 호출하는 부분
```

## 메모리와 할당
* 문자열 리터럴: 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행파일에 하드코딩된다. 효율적이지만 문자열이 변하지 않을 경우에만 사용 가능
* String: 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있습니다, 즉
    * 실행 중 메모리 할당자로부터 메모리를 요청해야 한다.
        * String::from 호출 시, 필요한 만큼 메모리를 요청하도록 구현되어 있다.
    * String 사용을 마쳤을 때 메모리를 해제할 (즉, 할당자에게 메모리를 반납할) 방법이 필요.
        * Rust는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결, drop 함수는 해당 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성해 넣을수 있게 되어 있으며, 위으 경우 String 개발자가 작성한 메모리 해제 코드가 실행된다, drop은 닫힌 중괄호가 나타나는 지점에서 자동으로 호출된다.

***

# 변수와 데이터 간 상호작용 방식: 이동

